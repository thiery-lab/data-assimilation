"""Three-dimensional model with chaotic non-linear dynamics.

Model originally proposed in:

> Lorenz, Edward Norton (1963).
> Deterministic nonperiodic flow.
> Journal of the Atmospheric Sciences. 20 (2): 130–141.
"""

from typing import Union, Optional, Callable
import numpy as np
from dapy.models.base import DiagonalGaussianModel, IntegratorModel
from dapy.integrators.lorenz_1963 import Lorenz1963Integrator


class Lorenz1963Model(IntegratorModel, DiagonalGaussianModel):
    """Three-dimensional model with chaotic non-linear dynamics

    Model dynamics defined by the system of ODEs

        dx_dt[0] = sigma * (x[1] - x[0])
        dx_dt[1] = x[0] * (rho - x[2]) - x[1]
        dx_dt[2] = x[0] * x[1] - beta * x[2]

    An implicit mid-point method (with fixed point iteration to solve for the update) is
    used here to integrate the system from an initial state with a diagonal Gaussian
    distribution. The observations are assumed to be generated given states generated by
    integrating forward the dynamics by a fixed time interval (the product of the
    intergrator time step and the number of steps per update). Optionally as well as the
    numerical integration based state update, additive Gaussian noise may be also
    included in these fixed interval state updates to represent the accumulated model
    error. The observations are assumed to be computed as a possibly non-linear function
    of the state plus additive Gaussian observation noise.

    References:

        1. Lorenz, Edward Norton (1963). Deterministic nonperiodic flow.
           Journal of the Atmospheric Sciences. 20 (2): 130–141.
    """

    def __init__(
        self,
        initial_state_mean: Union[float, np.ndarray] = 1.0,
        initial_state_std: Union[float, np.ndarray] = 0.05,
        state_noise_std: Optional[Union[float, np.ndarray]] = None,
        observation_function: Optional[Callable[[np.ndarray, int], np.ndarray]] = None,
        observation_noise_std: Union[float, np.ndarray] = 5.0,
        sigma: float = 10.0,
        rho: float = 28.0,
        beta: float = 8.0 / 3.0,
        time_step: float = 0.01,
        num_integrator_step_per_update: int = 10,
        fixed_point_tol: float = 1e-8,
        max_fixed_point_iter: int = 100,
        num_thread: int = 4,
    ):
        """
        Args:
            init_state_mean: Initial state distribution mean. Either a scalar or an
                array of shape `(3,)`.
            init_state_std: Initial state distribution standard deviation. Either a 
                scalar or an array of shape `(3,)`.
            state_noise_std: Standard deviation of additive Gaussian noise in state
                update. Either a scalar or an array of shape `(3,)`. Noise in
                each dimension assumed to be independent i.e. a diagonal noise
                covariance. If zero or `None` deterministic dynamics are assumed.
            observation_function: Function computing mean of observation(s) given
                state(s) at a given time index. Defaults to identity function in first
                (states) argument.
            observation_noise_std: Standard deviation of additive Gaussian noise in
                observations. Either a scalar or an array of shape `(dim_observation,)`.
                Noise in each dimension assumed to be independent i.e. a diagonal noise
                covariance.
            sigma: Coefficient in non-linear state update.
            rho: Coefficient in non-linear state update.
            beta: Coefficient in non-linear state update.
            time_step: Time step for implicit mid-point integrator.
            num_integrator_step_per_update: Number of integrator time-steps between
                successive observations and generated states.
            fixed_point_tol: Convergence tolerance for fixed point iteration.
            max_fixed_point_iter: Maximum number of iterations in fixed-point
                iterative solution of implicit update. `ConvergenceError`
                exception raised if iteration fails to converge within
                specified number.
            num_thread: Number of threads to parallelise integration of dynamics over.
        """
        self.observation_function = observation_function
        dim_state = 3
        if observation_function is None:
            dim_observation = dim_state
        else:
            dim_observation = observation_function(np.zeros(dim_state), 0).shape[-1]
        integrator = Lorenz1963Integrator(
            sigma=sigma,
            rho=rho,
            beta=beta,
            time_step=time_step,
            fixed_point_tol=fixed_point_tol,
            max_fixed_point_iter=max_fixed_point_iter,
            num_thread=num_thread,
        )
        super().__init__(
            integrator=integrator,
            num_integrator_step_per_update=num_integrator_step_per_update,
            dim_state=dim_state,
            dim_observation=dim_observation,
            initial_state_mean=initial_state_mean,
            initial_state_std=initial_state_std,
            state_noise_std=state_noise_std,
            observation_noise_std=observation_noise_std,
        )

    def _observation_mean(self, states, t):
        if self.observation_function is None:
            return states
        else:
            return self.observation_function(states, t)
